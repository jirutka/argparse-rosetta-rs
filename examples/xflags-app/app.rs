mod flags {
    // xflags! doesn't support `:` in types
    use std::path::PathBuf;

    xflags::xflags! {
        src "./app.rs"

        cmd app
        {
            repeated input: PathBuf
            /// Sets a number
            required --number number: u32
            /// Sets an optional number
            optional --opt-number opt_number: u32
            /// Sets width
            optional --width width: u32
        }
    }

    // generated start
    // The following code is generated by `xflags` macro.
    // Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
    #[derive(Debug)]
    pub struct App {
        pub input: Vec<PathBuf>,

        pub number: u32,
        pub opt_number: Option<u32>,
        pub width: Option<u32>,
    }

    impl App {
        #[allow(dead_code)]
        pub fn from_env_or_exit() -> Self {
            Self::from_env_or_exit_()
        }

        #[allow(dead_code)]
        pub fn from_env() -> xflags::Result<Self> {
            Self::from_env_()
        }

        #[allow(dead_code)]
        pub fn from_vec(args: Vec<std::ffi::OsString>) -> xflags::Result<Self> {
            Self::from_vec_(args)
        }
    }
    // generated end

    impl App {
        pub fn validate(&self) -> xflags::Result<()> {
            if let Some(width) = self.width {
                if width != 0 {
                    return Err(xflags::Error::new("width must be positive"));
                }
            }
            Ok(())
        }
    }
}

fn main() {
    let args = match flags::App::from_env() {
        Ok(args) => args,
        Err(err) => {
            err.exit();
        }
    };
    match args.validate() {
        Ok(()) => {}
        Err(err) => {
            err.exit();
        }
    }
    println!("{:#?}", args.number);
    println!("{:#?}", args.opt_number);
    println!("{:#?}", args.width);
    if 10 < args.input.len() {
        println!("{:#?}", args.input.len());
    } else {
        println!("{:#?}", args);
    }
}
